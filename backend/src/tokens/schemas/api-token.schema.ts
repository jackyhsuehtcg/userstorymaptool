import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type ApiTokenDocument = ApiToken & Document;

/**
 * ApiToken Schema - Manages API access tokens
 * Tokens are hashed for security (plaintext only shown on creation)
 */
@Schema({
  timestamps: true,
  collection: 'apiTokens',
})
export class ApiToken {
  /**
   * Unique identifier (generated by MongoDB)
   */
  _id?: Types.ObjectId;

  /**
   * Team ID that owns this token (required)
   */
  @Prop({ required: true, index: true })
  teamId!: string;

  /**
   * User ID who created this token (required)
   */
  @Prop({ required: true, index: true })
  createdBy!: string;

  /**
   * Token name/description
   */
  @Prop({ required: true, maxlength: 255 })
  name!: string;

  /**
   * SHA-256 hash of the token
   * The actual token is never stored, only the hash
   */
  @Prop({ required: true, unique: true, index: true })
  tokenHash!: string;

  /**
   * Prefix of token for identification (first 8 chars)
   * Helps users identify which token is being used
   */
  @Prop({ required: true, maxlength: 10 })
  tokenPrefix!: string;

  /**
   * Token expiration date (optional, null = never expires)
   */
  @Prop({ index: true, sparse: true })
  expiresAt?: Date | null;

  /**
   * Last used timestamp
   */
  @Prop({ index: true, sparse: true })
  lastUsedAt?: Date | null;

  /**
   * IP address of last use
   */
  @Prop()
  lastUsedIp?: string;

  /**
   * Scopes/permissions this token has
   * Examples: 'read:map', 'write:map', 'read:nodes', 'write:nodes'
   */
  @Prop({ type: [String], default: [] })
  scopes: string[] = [];

  /**
   * Is token currently active/valid
   */
  @Prop({ default: true, index: true })
  active: boolean = true;

  /**
   * Reason for revocation (if revoked)
   */
  @Prop()
  revokedReason?: string;

  /**
   * User who revoked the token
   */
  @Prop()
  revokedBy?: string;

  /**
   * Revocation timestamp
   */
  @Prop({ index: true, sparse: true })
  revokedAt?: Date | null;

  /**
   * Rate limit quota for this token (requests per minute)
   * null = no limit
   */
  @Prop()
  rateLimitPerMinute?: number | null;

  /**
   * Usage statistics
   */
  @Prop({ type: Object, default: {} })
  stats?: {
    totalRequests?: number;
    successfulRequests?: number;
    failedRequests?: number;
    lastResetAt?: Date;
  };

  /**
   * Allowed IPs (CIDR notation)
   * Empty array = all IPs allowed
   */
  @Prop({ type: [String], default: [] })
  allowedIps: string[] = [];

  /**
   * Metadata
   */
  @Prop({ type: Object, default: {} })
  metadata?: {
    environment?: 'development' | 'staging' | 'production';
    description?: string;
    [key: string]: any;
  };

  /**
   * Timestamps (managed by Mongoose)
   */
  createdAt?: Date;
  updatedAt?: Date;
}

export const ApiTokenSchema = SchemaFactory.createForClass(ApiToken);

/**
 * Indexes for ApiToken collection
 */

// Index for finding active tokens
ApiTokenSchema.index({ active: 1, teamId: 1 });

// Index for expiration cleanup
ApiTokenSchema.index({ expiresAt: 1 }, { sparse: true });

// Compound index for token validation
ApiTokenSchema.index({ tokenHash: 1, active: 1 });

// Index for revocation lookups
ApiTokenSchema.index({ revokedAt: 1 }, { sparse: true });

// Index for creation order
ApiTokenSchema.index({ createdAt: -1 });

// Compound index for team token management
ApiTokenSchema.index({ teamId: 1, createdBy: 1 });

/**
 * Pre-save middleware for validation
 */
ApiTokenSchema.pre('save', function (next) {
  // Validate that active and revoked are consistent
  if (!this.active && !this.revokedAt) {
    throw new Error('Revoked tokens must have revokedAt timestamp');
  }

  if (this.active && this.revokedAt) {
    throw new Error('Active tokens must not have revokedAt timestamp');
  }

  // Validate scopes format
  if (this.scopes && this.scopes.length > 0) {
    const scopeRegex = /^[a-z]+:[a-z]+$/;
    for (const scope of this.scopes) {
      if (!scopeRegex.test(scope)) {
        throw new Error(
          `Invalid scope format: ${scope}. Expected format: resource:action`,
        );
      }
    }
  }

  // Validate IP format if provided
  if (this.allowedIps && this.allowedIps.length > 0) {
    const ipRegex =
      /^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$|^([a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}(\/\d{1,3})?$/i;
    for (const ip of this.allowedIps) {
      if (!ipRegex.test(ip)) {
        throw new Error(`Invalid IP or CIDR format: ${ip}`);
      }
    }
  }

  next();
});

/**
 * Methods for API token operations
 */

/**
 * Check if token is expired
 */
ApiTokenSchema.methods.isExpired = function (): boolean {
  if (!this.expiresAt) {
    return false;
  }
  return new Date() > this.expiresAt;
};

/**
 * Check if token is revoked
 */
ApiTokenSchema.methods.isRevoked = function (): boolean {
  return !this.active || this.revokedAt !== null;
};

/**
 * Check if token can be used
 */
ApiTokenSchema.methods.canBeUsed = function (): boolean {
  return this.active && !this.isExpired();
};

/**
 * Update last used information
 */
ApiTokenSchema.methods.updateLastUsed = function (ipAddress: string): void {
  this.lastUsedAt = new Date();
  this.lastUsedIp = ipAddress;
};

/**
 * Increment usage stats
 */
ApiTokenSchema.methods.incrementStats = function (
  success: boolean = true,
): void {
  if (!this.stats) {
    this.stats = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
    };
  }

  this.stats.totalRequests = (this.stats.totalRequests || 0) + 1;
  if (success) {
    this.stats.successfulRequests = (this.stats.successfulRequests || 0) + 1;
  } else {
    this.stats.failedRequests = (this.stats.failedRequests || 0) + 1;
  }
};
