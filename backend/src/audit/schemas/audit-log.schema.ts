import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type AuditLogDocument = AuditLog & Document;

/**
 * AuditLog Schema - Records all changes and important operations
 * Used for compliance, debugging, and change tracking
 */
@Schema({
  timestamps: true,
  collection: 'auditLogs',
})
export class AuditLog {
  /**
   * Unique identifier (generated by MongoDB)
   */
  _id?: Types.ObjectId;

  /**
   * Team ID that this audit log belongs to (required)
   */
  @Prop({ required: true, index: true })
  teamId!: string;

  /**
   * Action type (required)
   */
  @Prop({
    required: true,
    enum: [
      'CREATE',
      'UPDATE',
      'DELETE',
      'IMPORT',
      'EXPORT',
      'LOGIN',
      'LOGOUT',
      'TOKEN_CREATE',
      'TOKEN_REVOKE',
      'PERMISSION_CHANGE',
      'SYNC',
      'OTHER',
    ],
    index: true,
  })
  action!: string;

  /**
   * Resource type affected
   */
  @Prop({
    enum: ['NODE', 'EDGE', 'USER', 'TOKEN', 'TEAM', 'SETTINGS', 'OTHER'],
    index: true,
  })
  resourceType?: string;

  /**
   * Resource ID affected
   */
  @Prop({ index: true, sparse: true })
  resourceId?: string;

  /**
   * User who performed the action
   */
  @Prop({ required: true, index: true })
  userId!: string;

  /**
   * User IP address
   */
  @Prop()
  ipAddress?: string;

  /**
   * User agent (browser/client info)
   */
  @Prop()
  userAgent?: string;

  /**
   * Status of the action
   */
  @Prop({
    enum: ['SUCCESS', 'FAILURE', 'PARTIAL'],
    default: 'SUCCESS',
    index: true,
  })
  status: string = 'SUCCESS';

  /**
   * Error message (if status is FAILURE)
   */
  @Prop()
  errorMessage?: string;

  /**
   * Changes made (for UPDATE operations)
   * Format: { field: { old: value, new: value }, ... }
   */
  @Prop({ type: Object })
  changes?: Record<string, { old: any; new: any }>;

  /**
   * Additional details/metadata
   */
  @Prop({ type: Object })
  details?: {
    count?: number;
    duration?: number;
    importedRecords?: number;
    [key: string]: any;
  };

  /**
   * Sensitive fields that were masked
   * Example: ['password', 'token', 'secret']
   */
  @Prop({ type: [String], default: [] })
  maskedFields: string[] = [];

  /**
   * Request ID for tracing
   */
  @Prop({ sparse: true })
  requestId?: string;

  /**
   * Session ID for tracking user session
   */
  @Prop({ sparse: true })
  sessionId?: string;

  /**
   * Related audit log IDs (for grouped operations)
   */
  @Prop({ type: [Types.ObjectId], default: [] })
  relatedLogs: Types.ObjectId[] = [];

  /**
   * Severity level for alerting
   */
  @Prop({
    enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    default: 'MEDIUM',
    index: true,
  })
  severity: string = 'MEDIUM';

  /**
   * Timestamps (managed by Mongoose)
   */
  createdAt?: Date;
  updatedAt?: Date;
}

export const AuditLogSchema = SchemaFactory.createForClass(AuditLog);

/**
 * Indexes for AuditLog collection
 */

// Compound index for finding logs by team and action
AuditLogSchema.index({ teamId: 1, action: 1 });

// Compound index for finding logs by team and user
AuditLogSchema.index({ teamId: 1, userId: 1 });

// Compound index for resource tracking
AuditLogSchema.index({ resourceType: 1, resourceId: 1 });

// Index for time-range queries (common for audit trails)
AuditLogSchema.index({ createdAt: -1, teamId: 1 });

// Index for severity-based alerts
AuditLogSchema.index({ severity: 1, createdAt: -1 });

// Index for status tracking
AuditLogSchema.index({ status: 1, teamId: 1 });

// Index for request tracing
AuditLogSchema.index({ requestId: 1 }, { sparse: true });

// Index for session tracking
AuditLogSchema.index({ sessionId: 1 }, { sparse: true });

// TTL index for automatic cleanup (keep 90 days by default)
AuditLogSchema.index(
  { createdAt: 1 },
  { expireAfterSeconds: 90 * 24 * 60 * 60 }, // 90 days
);

/**
 * Pre-save middleware for validation
 */
AuditLogSchema.pre('save', function (next) {
  // Validate that FAILURE status has error message
  if (this.status === 'FAILURE' && !this.errorMessage) {
    throw new Error('Error message required for FAILURE status');
  }

  // Validate that changes exist for UPDATE action
  if (this.action === 'UPDATE' && !this.changes) {
    throw new Error('Changes required for UPDATE action');
  }

  next();
});
