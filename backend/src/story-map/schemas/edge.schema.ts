import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type EdgeDocument = Edge & Document;

/**
 * Edge Schema - Represents relationships between nodes
 * Supports both parent-child edges (tree) and cross-team edges (graph)
 */
@Schema({
  timestamps: true,
  collection: 'edges',
})
export class Edge {
  /**
   * Unique identifier (generated by MongoDB)
   */
  _id?: Types.ObjectId;

  /**
   * Team ID that owns this edge (required)
   */
  @Prop({ required: true, index: true })
  teamId!: string;

  /**
   * Source node ID (required)
   */
  @Prop({ required: true, index: true })
  sourceNodeId!: Types.ObjectId;

  /**
   * Target node ID (required)
   */
  @Prop({ required: true, index: true })
  targetNodeId!: Types.ObjectId;

  /**
   * Edge type
   * - 'parent-child': Tree edge (managed by parentId in Node)
   * - 'cross': Cross-team relationship
   */
  @Prop({
    enum: ['parent-child', 'cross'],
    default: 'parent-child',
    index: true,
  })
  type: string = 'parent-child';

  /**
   * Cross-edge relationship kind (for filtering/styling)
   * Examples: 'depends-on', 'blocks', 'relates-to', 'implements'
   */
  @Prop({ sparse: true })
  kind?: string;

  /**
   * Target team ID (for cross-team edges)
   */
  @Prop({ sparse: true, index: true })
  targetTeamId?: string;

  /**
   * Edge label/description
   */
  @Prop({ maxlength: 500 })
  label?: string;

  /**
   * Is this edge active/valid
   */
  @Prop({ default: true })
  active: boolean = true;

  /**
   * Order for rendering
   */
  @Prop({ default: 0 })
  order: number = 0;

  /**
   * User who created the edge
   */
  @Prop()
  createdBy?: string;

  /**
   * User who last modified the edge
   */
  @Prop()
  modifiedBy?: string;

  /**
   * Metadata for visualization
   */
  @Prop({ type: Object, default: {} })
  metadata?: {
    color?: string;
    style?: string;
    animated?: boolean;
    [key: string]: any;
  };

  /**
   * Timestamps (managed by Mongoose)
   */
  createdAt?: Date;
  updatedAt?: Date;
}

export const EdgeSchema = SchemaFactory.createForClass(Edge);

/**
 * Indexes for Edge collection
 */

// Compound index for finding edges from a node
EdgeSchema.index({ sourceNodeId: 1, type: 1 });

// Compound index for finding edges to a node
EdgeSchema.index({ targetNodeId: 1, type: 1 });

// Compound index for team edges
EdgeSchema.index({ teamId: 1, type: 1 });

// Cross-team edge lookups
EdgeSchema.index({ targetTeamId: 1, type: 1 }, { sparse: true });

// Active edges by team
EdgeSchema.index({ teamId: 1, active: 1 });

// Cross edges by kind
EdgeSchema.index({ kind: 1, type: 1 }, { sparse: true });

// Creation order
EdgeSchema.index({ createdAt: -1 });

/**
 * Pre-save middleware for validation
 */
EdgeSchema.pre('save', function (next) {
  // Validate that source and target are different
  if (this.sourceNodeId.equals(this.targetNodeId)) {
    throw new Error('Source and target nodes cannot be the same');
  }

  // Validate cross-edge has targetTeamId
  if (this.type === 'cross' && !this.targetTeamId) {
    throw new Error('Cross-edge must have targetTeamId');
  }

  // Validate parent-child edge doesn't have targetTeamId
  if (this.type === 'parent-child' && this.targetTeamId) {
    throw new Error('Parent-child edge should not have targetTeamId');
  }

  next();
});
