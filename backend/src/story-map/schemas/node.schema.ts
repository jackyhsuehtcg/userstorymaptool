import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export type NodeDocument = Node & Document;

/**
 * Node Schema - Represents a story map node
 * Supports hierarchical structure with ancestor path for cycle detection
 */
@Schema({
  timestamps: true,
  collection: 'nodes',
})
export class Node {
  /**
   * Unique identifier (generated by MongoDB)
   */
  _id?: Types.ObjectId;

  /**
   * Team ID the node belongs to (required)
   */
  @Prop({ required: true, index: true })
  teamId!: string;

  /**
   * Parent node ID (null for root nodes)
   */
  @Prop({ index: true, sparse: true })
  parentId?: Types.ObjectId | null;

  /**
   * Ancestor path for cycle detection and hierarchy
   * Format: [id1, id2, id3, ...] representing path from root to this node
   */
  @Prop({ type: [Types.ObjectId], default: [] })
  ancestorPath: Types.ObjectId[] = [];

  /**
   * Depth in hierarchy (0 for root nodes)
   */
  @Prop({ default: 0 })
  depth: number = 0;

  /**
   * Node summary/title (required)
   */
  @Prop({ required: true, maxlength: 500 })
  summary!: string;

  /**
   * Detailed description
   */
  @Prop({ maxlength: 2000 })
  description?: string;

  /**
   * Ticket/issue reference (e.g., JIRA ticket)
   */
  @Prop({ sparse: true })
  ticketId?: string;

  /**
   * Custom labels/tags
   */
  @Prop({ type: [String], default: [] })
  labels: string[] = [];

  /**
   * Order among siblings (for sorting)
   */
  @Prop({ default: 0 })
  order: number = 0;

  /**
   * Node status
   */
  @Prop({
    enum: ['active', 'archived', 'deleted'],
    default: 'active',
  })
  status: string = 'active';

  /**
   * User who created the node
   */
  @Prop()
  createdBy?: string;

  /**
   * User who last modified the node
   */
  @Prop()
  modifiedBy?: string;

  /**
   * Metadata for visualization
   */
  @Prop({ type: Object, default: {} })
  metadata?: {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    [key: string]: any;
  };

  /**
   * Timestamps (managed by Mongoose)
   */
  createdAt?: Date;
  updatedAt?: Date;
}

export const NodeSchema = SchemaFactory.createForClass(Node);

/**
 * Indexes for Node collection
 */

// Compound index for fast queries by teamId and parentId
NodeSchema.index({ teamId: 1, parentId: 1 });

// Index for ancestor path queries (cycle detection)
NodeSchema.index({ ancestorPath: 1 });

// Index for depth-based queries
NodeSchema.index({ teamId: 1, depth: 1 });

// Index for status queries
NodeSchema.index({ status: 1, teamId: 1 });

// Index for creation order
NodeSchema.index({ createdAt: -1 });

// Index for ticket lookups
NodeSchema.index({ ticketId: 1, teamId: 1 }, { sparse: true });

// Text index for full-text search
NodeSchema.index({ summary: 'text', description: 'text' });

// Virtualsremoved as they're not needed for this schema

/**
 * Pre-save middleware for validation
 */
NodeSchema.pre('save', function (next) {
  // Validate that a node doesn't have itself as ancestor
  if (this.ancestorPath.includes(this._id)) {
    throw new Error('Node cannot be its own ancestor (cycle detected)');
  }

  // Validate summary is not empty
  if (!this.summary || this.summary.trim().length === 0) {
    throw new Error('Summary cannot be empty');
  }

  next();
});
